# AVL Tree

定義 :
- AVL Tree 是一種自平衡的 Binary Search Tree（BST）。
- 在 插入/刪除 操作下，越平衡（高度越低），效率越高。
- BST 的 worst case 是 skewed tree，時間複雜度為 O(n)。
- AVL Tree 因為保持平衡，不會出現 O(n) 的情況。

平衡因子（Balance Factor）:
- 定義：hL - hR（左子樹高度 - 右子樹高度）
- 成為 AVL Tree 的前提是先為 BST。
- 每個節點的平衡因子必須在 [-1, 0, 1] 範圍內。
- 若高度為 h 的 AVL Tree，其最多節點數為：F_{h+2}-1 （F 為 Fibonacci 數列）

結構:

           D
          / \
         L   R
       (hL)   (hR)


範例一：合法 AVL Tree

          20
         /  \
       15    32
      /  \
     8    18

範例二：非法 AVL Tree

          30
         /  \
       15    40
      /  \
     8    22
           \
           28

- 問題：節點 28 < 30，但未放在左子樹 → 違反 BST 性質 → 此非 AVL Tree ❌


AVL Tree 建構範例：
插入序列 [2, 5, 8, 10, 1, 3, 15]
給定數列：2, 5, 8, 10, 1, 3, 15
請依序插入並建構 AVL Tree。

    2
     \
      5
       \
        8


- 插入順序造成右傾（skewed）結構。
- 不符合 AVL Tree 的平衡性。

中間結果：部分平衡（比較平衡）

        5
       / \
      2   8
     / \    \
    1   3    10
             \
              15

- 插入後進行部分旋轉與重構。
- 雖然比原始 BST 更平衡，但仍未達到最佳 AVL 結構。

最終結果：完全平衡 AVL Tree（平衡後）

        5
       / \
      2   10
     / \  / \
    1  3 8  15

- 每個節點的平衡因子皆在 [-1, 0, 1] 範圍內。
- 完整符合 AVL Tree 的定義。


## Linked list、array、AVL tree時間複雜度比較表

| 操作類型             | 陣列（Array）                     | 鍊結串列（Linked List） | AVL 樹（AVL Tree）     |
|----------------------|----------------------------------|--------------------------|------------------------|
| 搜尋 X               | 可用 binary search → `O(log n)`  | 須逐一比對 → `O(n)`      | 平衡搜尋 → `O(log n)`  |
| 搜尋第 k 個元素      | 直接索引 → `O(1)`                 | 須走訪 k 次 → `O(k)`     | 須走訪 → `O(log n)`    |
| 插入 X               | 插入後須整體位移 → `O(n)`         | 插入節點 → `O(1)`        | 平衡插入 → `O(log n)`  |
| 刪除第 k 個元素      | 刪除後須位移 `n-k` 次 → `O(n-k)`  | 須走訪 k 次 → `O(k)`     | 平衡刪除 → `O(log n)`  |
| 依序輸出             | 須逐一走訪 → `O(n)`               | 須逐一走訪 → `O(n)`      | 中序走訪 → `O(n)`      |


## 整理: B.S.T、AVL Tree、Heap time complexity 

| Table Size (m)               |             beat case        |      worse case                |
|------------------------------|------------------------------|--------------------------------|      
|  B.S.T                       |            o(logn)           |  o(n)(斜曲樹時)                 |
|  AVL                         |            o(logn)           |  NO(解決不平衡，故無worse case)  |
|  haep                        |      insert = o(logn)        |  找最大值 = o(1)                |
